<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react native子组件不刷新]]></title>
    <url>%2F2019%2F03%2F26%2Fngproblemone%2F</url>
    <content type="text"><![CDATA[先说说我犯的错误子组件初次加载时有值 当改变父组件值时 子组件传递的值没有变化原因：我把传递的值定义在了 子页面的 12345678constructor(props) &#123; super(props); let &#123;year,data&#125; = props; this.state=&#123; year:year, data:data, &#125;&#125; 应该定义在render里面 123456789101112render()&#123; const &#123;navigation,year,data&#125; = this.props; this.state=&#123; data:data, year:year, &#125;; renturn&#123; this.props.data.map((data, index) =&gt; &#123; ... &#125;) &#125;&#125; 在网上百度了一下通常出现的几种错误，在这里总结一下： 1.父组件传递给子组件的props的值没有改变:我理解的意思为 传递的值不是改变的值 传递的值没有变化 2、父组件的render没有执行。父组件没有刷新，当前页面数组没有改变 传递的值没有setState 或者是 setState 没有改变 在编辑器console查看值是否改变 3、在父组件中，子组件用在FlatList中FlatList的刷新机制是：默认情况下，如果data的值地址不改变，即使data中某个对象的某个属性值发生了改变，也不会触发FlatList的更新。所以需要设置extraData。比如data={userList}，如果你想在userList中某个item的属性（假设为头像）发生改变时，FlatList的展示内容跟着变化。那应该这么设置 1&lt;FlatList data=&#123;userList&#125; extraData=&#123;userList&#125; /&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[git 快捷方式]]></title>
    <url>%2F2019%2F03%2F21%2Fgitquick%2F</url>
    <content type="text"><![CDATA[npm install 下载更新资源包npm install gulp -g 全局下载gulpgit clone （目标文件地址）git fetch 更新所有分支git checkout 切换分支git branch 查看分支git branch (分支名称) 创建分支git checkout -b (分支名称) 新建分支并打开git merge 合并分支git branch -D (分支名称) 删除分支git init 创建本地gitgit add. 提交本地git status 查看状态git pull 更新 git提交步骤：1.git add .2.git commit 提交到本地3.git commit -m ‘提交到本地注释’4.git push 提交到git 合并分支git checkout dev 切换到devgit merge master 将dev与 master 合并（合并到dev） 要更新所有分支，命令可以简写为：git fetch 更新单个分支git pull origin msggit pull origin inquiry (分支名称) 不想提交暂存git stash save “ln” 暂存分支 暂存分支一个 叫 li 的 切换分支到你想要合并的分支 合并然后回到上个分支git stash list查看暂存版本如果只有一个git stash pop 即可还原未提交的文件如果多个git stash pop stash@{1}恢复指定的进度到工作区。stash_id是通过git stash list命令得到的通过git stash pop命令恢复进度后，会删除当前进度。继续编辑 新建并拉取线上版本git checkout -b v1.0.0 origin/v1.0.0 git branch 查看分支 一屏显示不全按回车显示 按q退出当前命令]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-native 导航]]></title>
    <url>%2F2019%2F03%2F20%2Fmy-reactnative-two%2F</url>
    <content type="text"><![CDATA[StackNavigator ，屏幕上方的导航栏类似于普通的NavigatorTabNavigator 相当于ios 里面的TabBarController,屏幕下方的标签栏DrawerNavigator 抽屉效果 侧边滑出以下都是react-native 0.57.2版本的写法1import &#123;createDrawerNavigator, createStackNavigator, createSwitchNavigator,createBottomTabNavigator&#125; from &apos;react-navigation&apos;; 通过navigationOptions 可以制定导航器显示屏幕的方式（列如：头部标题，选项卡标签等）； StackNavigator1234567891011121314151617181920212223242526272829createStackNavigator(&#123; ResetPwd:&#123; screen: ResetPwd, navigationOptions:props=&gt; (&#123; headerLeft: ( &lt;TouchableHighlight onPress=&#123;() =&gt; &#123; props.navigation.openDrawer(); Keyboard.dismiss(); if (Picker &amp;&amp; Picker !== null) &#123; Picker.hide(); &#125; &#125;&#125;&gt; &lt;Image source=&#123;require(&apos;../assets/imgs/menu.png&apos;)&#125; style=&#123;[commonStyle.menu, commonStyle.navicon]&#125; &gt; &lt;/Image&gt; &lt;/TouchableHighlight&gt; ), headerStyle: &#123; paddingTop: Platform.OS === &quot;ios&quot; ? 0 : StatusBar.currentHeight, backgroundColor: commonStyle.themeColor, height: ScreenUtil.scaleHeight(96) + (Platform.OS === &quot;ios&quot; ? 0 : StatusBar.currentHeight), &#125;, headerTintColor: commonStyle.white, headerRight: ( &lt;RightComponent navigation=&#123;props.navigation&#125;/&gt; ), &#125;) &#125;&#125;) DrawerNavigator123456789101112131415161718192021const DrawerNav = createDrawerNavigator(&#123; Index:&#123; screen:Index, navigationOptions:&#123; title:&apos;首页&apos; &#125; &#125;&#125;, &#123; drawerWidth: ScreenUtil.scaleWidth(540), // 展示的宽度 drawerPosition: &apos;left&apos;, // 抽屉在左边还是右边 drawerBackgroundColor: commonStyle.white,//默认侧边栏颜色是white contentOptions: &#123; // initialRouteName: &apos;index&apos;, // 默认页面组件 activeTintColor: commonStyle.white, // 选中文字颜色 activeBackgroundColor: commonStyle.origin, // 选中背景颜色 inactiveTintColor: &apos;#0c0c0c&apos;, // 未选中文字颜色 inactiveBackgroundColor: commonStyle.white, // 未选中背景颜色 &#125;, contentComponent: props =&gt; &lt;LeftNavRouter &#123;...props&#125;/&gt;,&#125;,) 自定义侧边导航 123456789101112131415161718192021222324252627282930export default class LeftNavRouter extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; const props = this.props; const &#123;navigation&#125; = this.props; return ( &lt;SafeAreaViewPlus style=&#123;&#123;flex: 1,&#125;&#125; topColor=&#123;commonStyle.themeColor&#125; bottomInset=&#123;false&#125; bottomColor=&#123;&apos;#fefefe&apos;&#125; &gt; &lt;DrawerHeader user=&#123;this.state.user&#125;/&gt; &lt;ScrollView style=&#123;[commonStyle.menuout, &#123;flex: 1,&#125;]&#125;&gt; &lt;DrawerItems &#123;...props&#125; // onItemPress=&#123; // this.state.menuleftdata // &#125; items=&#123;this.state.menuleftdata&#125; itemStyle=&#123;[commonStyle.menuuser, commonStyle.menuusertop, ]&#125; labelStyle=&#123;&#123;margin: 0, fontSize: ScreenUtil.setSpText(30), fontWeight: &apos;normal&apos;&#125;&#125; /&gt; &lt;/ScrollView&gt; &lt;/SafeAreaViewPlus&gt; ) &#125;&#125; TabNavigator123456789101112131415161718192021222324252627282930313233343536373839404142434445const BottomRouter = createBottomTabNavigator( &#123; Home: &#123; screen: RootStack, navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; tabBarIcon: (&#123;focused, horizontal, tintColor&#125;) =&gt; &#123; const &#123;routeName&#125; = navigation.state; let iconName = `ios-information-circle$&#123;focused ? &apos;&apos; : &apos;-outline&apos;&#125;`; return &lt;Ionicons name=&#123;iconName&#125; size=&#123;horizontal ? 20 : 25&#125; color=&#123;tintColor&#125;/&gt;; &#125;, &#125;), &#125;, Settings: &#123; screen: SettingsStack, navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; tabBarIcon: (&#123;focused, horizontal, tintColor&#125;) =&gt; &#123; const &#123;routeName&#125; = navigation.state; let iconName = `ios-star$&#123;focused ? &apos;&apos; : &apos;-outline&apos;&#125;`; return &lt;Ionicons name=&#123;iconName&#125; size=&#123;horizontal ? 20 : 25&#125; color=&#123;tintColor&#125;/&gt;; &#125;, &#125;), &#125;, &#125;, &#123; /*navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; tabBarIcon: (&#123;focused, horizontal, tintColor&#125;) =&gt; &#123; const &#123;routeName&#125; = navigation.state; let iconName; if (routeName === &apos;Home&apos;) &#123; iconName = `ios-information-circle$&#123;focused ? &apos;&apos; : &apos;-outline&apos;&#125;`; &#125; else if (routeName === &apos;Settings&apos;) &#123; iconName = `ios-remove$&#123;focused ? &apos;&apos; : &apos;-outline&apos;&#125;`; &#125; // You can return any component that you like here! We usually use an // icon component from react-native-vector-icons return &lt;Ionicons name=&#123;iconName&#125; size=&#123;horizontal ? 20 : 25&#125; color=&#123;tintColor&#125;/&gt;; &#125;, &#125;),*/ tabBarOptions: &#123; activeTintColor: &apos;tomato&apos;, inactiveTintColor: &apos;gray&apos;, &#125;, &#125;); 设置各个页面的展示顺序 如果想设置侧边栏通屏 所有的头部或者底部导航页面应该放在设置侧边栏导航下面 createSwitchNavigator 1234567891011121314151617181920212223//welcome为欢迎页export default createSwitchNavigator( &#123; welcome: WelComePage, LoginLoadingOut:LoginLoadingScreen, Login: &#123; screen: Login, // navigationOptions: &#123; // header: null // &#125; &#125;, WebViewListout:&#123; screen:WebViewList, &#125;, DrawerNav: &#123; screen: DrawerNav, &#125;, // WebViewList:WebViewList, &#125;, &#123; initialRouteName: &apos;LoginLoadingOut&apos;, &#125;); Screen navigation prop （屏幕导航属性）Screen navigationOptions （屏幕导航选项）：通过navigation 可以完成屏幕之间的调度操作，列如打开另一个屏幕 设置单个页面 navigation 123456static navigationOptions = (&#123; navigation &#125;) =&gt; &#123; const &#123;params&#125; = navigation.state; return &#123; title: params &amp;&amp; params.title? params.title:&apos;审批详情&apos;, &#125;&#125;; 页面间路由跳转 123456onPress=&#123; () =&gt;this.props.navigation.navigate(&apos;Loading&apos;, &#123; router: this.props.navigation.state, loadTime: 1000 &#125;)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建react native 的window开发环境]]></title>
    <url>%2F2019%2F03%2F20%2Fmy-reactnative-one%2F</url>
    <content type="text"><![CDATA[经过一段时间学习react native 觉得虽然难但其实蛮好用的，怕自己以后忘记遇到的，决定记录下来12## 搭建开发环境官网搭建开发环境地址（https://reactnative.cn/docs/getting-started.html) 安装依赖下载安装node Python 2版本 jdk 1.8版本Python2下载地址下载教程 Jdk历史版本Jdk1.812JDK下载完成后配置电脑-属性-高级系统设置-环境变量-创建一个名为JAVA_HOME的环境变量（系统或用户变量均可） &lt;img al’t=”” src=”/images/2.png” height=”60”&gt;跟着步骤下载完外部插件 12345npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --globalnpm install -g yarn react-native-cliyarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 安装完yarn之后就可以用yarn代替npm了例如用yarn代替npm install命令用yarn add 某第三方库名代替npm install –save 某第三方库名。 安装Android开发环境1.首先下载和安装 Android Studio 翻墙安装(https://developer.android.com/studio/index.html) 下载模拟器(https://visualstudio.microsoft.com/zh-hans/vs/msft-android-emulator/?rr=https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3Dth-D5yfbKYOC8eZHbk7ujhLM8QWkZPGEJ8qCKkJ5T02VQQc-n2h1IiSPbW0MYjFiuziIL__QabbEn_BQBgfG7q%26wd%3D%26eqid%3Df15261c00003ac7f000000025bbeea6e) 安装模拟器注意 1.配置Android的环境变量电脑-属性-高级系统设置-环境变量-创建一个名为ANDROID_HOME的环境变量（系统或用户变量均可） 2.安装Android SDK 3.运行模拟器 可以直接在Android Studio 里面点击运行 不喜欢Android Studio编辑的可以在Package.json script增加三个命令 123&quot;v&quot;: &quot;D:/AndroidSDK/tools/emulator.exe -netdelay none -netspeed full -avd Nexus_5X_API_26&quot;,&quot;build&quot;: &quot;react-native run-android&quot;,&quot;server&quot;: &quot;react-native start --reset-cache&quot;, npm run v 启动虚拟器（D:/AndroidSDK/tools android-studio sdk目录 Nexus_5X_API_26虚拟机名称） npm run build （运行android ios开发写上 react-native run-ios） npm run server 启动虚拟器服务 4.配置webstrom 1.Setting 设置选择打开项目 2.下载工具 5.启动真机 启动真机调试 打开手机版本号点击 打开开发者模式 打开usb允许调试如果红屏报错执行Adb devicesadb reverse tcp:8081 tcp:8081adb shell input keyevent 82摇晃手机出现选择第三个 改变刷新方式为实时刷新]]></content>
  </entry>
  <entry>
    <title><![CDATA[用Hexo写出第一篇博客]]></title>
    <url>%2F2018%2F08%2F16%2Flayout%2F</url>
    <content type="text"><![CDATA[创建博客定位到我们的hexo根目录，执行命令1$ hexo new "你的新文章的名字" 写作经过上面上面一系列的准备工作，现在差不多就可以安心的写作了。打开 source/_posts 文件夹下刚创建的 Markdown 文件，你会发现有如下内容：12345---title: hexo-blogdate: 2017-01-13 16:07:32tags:--- 注意，这里的 title 是可以随便改的，当然了 date 也是可以改，不过没有改的必要；这里要说一下 tags 这个属性，如果需要配置多个有两种方式：1tags: [tag1, tag2, tag3] 或者1234tags: - tag1 - tag2 - tag3 之前说过 Hexo 是支持 Markdown 的所有功能的，所以，下面去学习一下 Markdown 的语法规范。详情来自(https://www.jianshu.com/p/56d99a3049a5)]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建github博客]]></title>
    <url>%2F2018%2F08%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[创建一个仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 提交你的md到你新创建的仓库中 git init git add README.md git commit -m “first commit” git remote add origin https://github.com/test git push -u origin master 安装hexo1.安装 1npm install -g hexo 2.初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\Workspaces\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12345$ cd /f/Workspaces/hexo/$ hexo init//hexo会自动下载一些文件到这个目录，包括node_modules$ hexo g #生成$ hexo s #启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： More info: Writing 3.修改主题官方主题：https://hexo.io/themes/个人比较喜欢的主题：hexo-theme-next（https://github.com/iissnan/hexo-theme-next）1$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next 下载后的主题都在 hexo/themes,修改_config.yml中的theme: landscape改为theme: next，然后重新执行hexo g来重新生成。如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 4.上传之前在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 5.上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。首先，ssh key肯定要配置好。其次，配置_config.yml中有关deploy的部分：正确写法：1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master 还需要安装一个插件：1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey).打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： 6. 保留CNAME、README.md等文件提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的：由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 7. 常用hexo命令hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传More info: Server 摘自：（http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html）]]></content>
  </entry>
</search>
